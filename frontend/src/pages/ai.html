<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Smart Pong - AI Enhanced with Difficulty</title>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: black; }
    canvas { width: 100%; height: 100%; display: block; }
    #scoreboard {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: monospace;
      font-size: 24px;
      z-index: 10;
      display: none;
    }
    #difficultyMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: white;
      font-family: monospace;
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      z-index: 20;
    }
    #difficultyMenu button {
      font-size: 18px;
      margin: 10px;
      padding: 8px 20px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #555;
      color: white;
      transition: background-color 0.3s;
    }
    #difficultyMenu button:hover {
      background: #888;
    }
    #scoreLimitContainer {
  margin: 20px auto;
  padding: 15px 25px;
  width: fit-content;
  background: #222;           /* тёмный фон */
  color: #eee;                /* светлый текст */
  border-radius: 12px;
  box-shadow: 0 6px 15px rgba(0,0,0,0.4);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  text-align: center;
}

#scoreLimitContainer label {
  font-weight: 600;
  margin-right: 10px;
  font-size: 16px;
}

#scoreLimitContainer input[type="number"] {
  width: 60px;
  padding: 6px 10px;
  border-radius: 8px;
  border: none;
  font-size: 16px;
  margin-right: 10px;
  outline: none;
}

#scoreLimitContainer button {
  background: #4caf50;
  border: none;
  color: white;
  padding: 7px 15px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: background 0.3s ease;
}

#scoreLimitContainer button:hover {
  background: #45a049;
}

#scoreLimitDisplay {
  margin-left: 15px;
  font-size: 16px;
  font-weight: 600;
  vertical-align: middle;
}


  </style>
</head>
<body>
  <div id="difficultyMenu">
    <div>Выберите сложность:</div>
    <button data-diff="easy">Легко</button>
    <button data-diff="medium">Средне</button>
    <button data-diff="hard">Сложно</button>
  </div>
  <div id="scoreLimitContainer">
    <label for="scoreLimitInput">Play to:</label>
    <input type="number" id="scoreLimitInput" value="5" min="1" max="100" step="1" />
    <button onclick="applyScoreLimit()">Apply</button>
    <span id="scoreLimitDisplay">Current limit: 5</span>
  </div>




  <div id="winnerScreen" style="
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 30px 50px;
  background-color: rgba(0, 0, 0, 0.9);
  color: white;
  font-size: 24px;
  border-radius: 15px;
  box-shadow: 0 0 15px rgba(255,255,255,0.2);
  text-align: center;
  z-index: 1000;
">
  <div id="winnerText">Player wins!</div>
  <button id="restartButton" style="
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    border: none;
    border-radius: 10px;
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
  ">Play Again</button>
</div>




  
  
  <div id="scoreboard">Player: 0 | AI: 0</div>
  <div id="winnerMessage" style="margin-top: 10px; font-weight: 700; font-size: 18px; color: #ffcc00;"></div>
  <canvas id="renderCanvas"></canvas>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scoreboard = document.getElementById("scoreboard");
    const difficultyMenu = document.getElementById("difficultyMenu");
    const ScorCont = document.getElementById("scoreLimitContainer");
    let maxScore = 5;

    let difficulty = null; // выбранная сложность

    // Настройки точности AI в зависимости от сложности
    const difficultySettings = {
      easy: { randomness: 3, reactionDelay: 1500 },    // большой разброс и медленная реакция
      medium: { randomness: 1.5, reactionDelay: 1000 }, // средний разброс и реакция
      hard: { randomness: 0.5, reactionDelay: 600 }    // почти точный AI и быстрая реакция
    };
    
    function applyScoreLimit() {
      const input = document.getElementById("scoreLimitInput");
      const value = parseInt(input.value);
      if (!isNaN(value) && value > 0 && value <= 100) {
        maxScore = value;
        document.getElementById("scoreLimitDisplay").textContent = `Current limit: ${maxScore}`;
      } else {
        alert("Please enter a valid score limit between 1 and 100.");
      }
    }
    
        // Обработчик выбора сложности
        difficultyMenu.querySelectorAll("button").forEach(button => {
          button.onclick = () => {
            difficulty = button.getAttribute("data-diff");
            difficultyMenu.style.display = "none";
            ScorCont.style.display = "none";
            scoreboard.style.display = "block";
            startGame();
          };
        });

    function startGame() {
      const scene = createScene();
      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    function showWinner(winnerName) {
  const winnerScreen = document.getElementById("winnerScreen");
  const winnerText = document.getElementById("winnerText");
  winnerText.textContent = `${winnerName} wins!`;
  winnerScreen.style.display = "block";
  engine.stopRenderLoop(); // остановить игру
}

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3.Black();

      const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 25, -30), scene);
      camera.setTarget(new BABYLON.Vector3(0, 0, 0));
      camera.rotation.x = Math.PI / 4;

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 1;

      const paddleWidth = 4, paddleHeight = 1;

      const player = BABYLON.MeshBuilder.CreateBox("player", {width: paddleWidth, height: paddleHeight, depth: 1}, scene);
      player.position.z = -15;
      player.position.y = 0.5;
      player.material = new BABYLON.StandardMaterial("blue", scene);
      player.material.diffuseColor = new BABYLON.Color3(0.1, 0.3, 1);

      const ai = BABYLON.MeshBuilder.CreateBox("ai", {width: paddleWidth, height: paddleHeight, depth: 1}, scene);
      ai.position.z = 15;
      ai.position.y = 0.5;
      ai.material = new BABYLON.StandardMaterial("red", scene);
      ai.material.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);

      const ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 1}, scene);
      ball.position.y = 0.5;

      let ballSpeed = 0.4;
      let ballVelocity = new BABYLON.Vector3(0, 0, ballSpeed * (Math.random() > 0.5 ? 1 : -1));

      const speedMultiplier = 1.05;
      const maxBallSpeed = 0.6;

      let playerScore = 0, aiScore = 0;

      const winnerMessage = document.getElementById('winnerMessage');

      const updateScore = () => {
        scoreboard.textContent = `Player: ${playerScore} | AI: ${aiScore}`;

        if (playerScore == maxScore || aiScore == maxScore) {
          if (playerScore == maxScore) {
            showWinner("Player");
          } else {
            showWinner("AI");
          }
          // Здесь можно добавить логику остановки игры, если нужно
        } else {
          // Если игра продолжается, скрываем сообщение о победителе
          winnerMessage.textContent = '';
        }
      };

      const groundWidth = 22;
      const groundHeight = 35;
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: groundWidth, height: groundHeight}, scene);
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.2);
      ground.material = groundMat;



      // Добавим "дорожные" полоски по центру поля
      const stripeWidth = 1.5;
      const stripeHeight = 0.1;
      const stripeDepth = 0.5;
      const stripeCount = 12;
      const stripeSpacing = 2;

      for (let i = 0; i < stripeCount; i++) {
        const stripe = BABYLON.MeshBuilder.CreateBox(`stripe${i}`, {
          width: stripeWidth,
          height: stripeHeight,
          depth: stripeDepth
        }, scene);
        stripe.position.x = 5.2 + (-groundHeight/2 + stripeDepth/2 + i * stripeSpacing); // по центру поля по оси X
        stripe.position.y = 0.01; // чуть выше земли
        stripe.position.z = 0; // равномерно по оси Z
        const stripeMat = new BABYLON.StandardMaterial(`stripeMat${i}`, scene);
        stripeMat.diffuseColor = new BABYLON.Color3(1, 1, 1); // белый цвет
        stripe.material = stripeMat;
      }




      const wallThickness = 1;
      const wallHeight = 2;

      const leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", {width: wallThickness, height: wallHeight, depth: groundHeight}, scene);
      leftWall.position.x = -groundWidth/2 - wallThickness/2;
      leftWall.position.y = wallHeight / 2;
      leftWall.position.z = 0;
      leftWall.material = new BABYLON.StandardMaterial("wallMat", scene);
      leftWall.material.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);

      const rightWall = BABYLON.MeshBuilder.CreateBox("rightWall", {width: wallThickness, height: wallHeight, depth: groundHeight}, scene);
      rightWall.position.x = groundWidth/2 + wallThickness/2;
      rightWall.position.y = wallHeight / 2;
      rightWall.position.z = 0;
      rightWall.material = new BABYLON.StandardMaterial("wallMat2", scene);
      rightWall.material.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);

      const input = { a: false, d: false };
      window.addEventListener("keydown", e => {
        if (e.key === "a" || e.key === "ArrowLeft") input.a = true;
        if (e.key === "d" || e.key === "ArrowRight") input.d = true;
      });
      window.addEventListener("keyup", e => {
        if (e.key === "a" || e.key === "ArrowLeft") input.a = false;
        if (e.key === "d" || e.key === "ArrowRight") input.d = false;
      });

      function paddleHit(paddle) {
        return (
          Math.abs(ball.position.z - paddle.position.z) < 1 &&
          Math.abs(ball.position.x - paddle.position.x) < paddleWidth / 2 + 0.5
        );
      }

      function reflectBall(paddle) {
        let relativeIntersectX = (ball.position.x - paddle.position.x) / (paddleWidth / 2);
        relativeIntersectX = Math.min(Math.max(relativeIntersectX, -1), 1);

        const maxBounceAngle = Math.PI * 75 / 180;
        let bounceAngle = relativeIntersectX * maxBounceAngle;

        let speed = ballVelocity.length();
        let directionZ = paddle.position.z < 0 ? 1 : -1;

        speed = Math.min(speed * speedMultiplier, maxBallSpeed);

        ballVelocity.x = speed * Math.sin(bounceAngle);
        ballVelocity.z = speed * Math.cos(bounceAngle) * directionZ;
      }

      function resetBall() {
        player.position.x = 0;
        ai.position.x = 0;
        if (maxScore)
        ball.position = new BABYLON.Vector3(0, 0.5, 0);
        ballVelocity = new BABYLON.Vector3(0, 0, ballSpeed * (Math.random() > 0.5 ? 1 : -1));
      }

      let baseMoveSpeed = 20;

      let aiTargetX = 0;
      let lastPredictionTime = 0;

      function predictBallPosition() {
        // AI точность и задержка зависят от сложности
        const { randomness, reactionDelay } = difficultySettings[difficulty];

        const now = performance.now();
        if (now - lastPredictionTime < reactionDelay) {
          return; // ещё рано делать новое предсказание
        }
        lastPredictionTime = now;

        if (ballVelocity.z > 0) {
          let prediction = ball.position.clone();
          let predictedVel = ballVelocity.clone();
          let steps = 0;
          const maxSteps = 1000;

          while (prediction.z < ai.position.z && steps++ < maxSteps) {
            prediction.addInPlace(predictedVel);

            // отражение от боковых стен
            if (prediction.x <= -groundWidth / 2 + 0.5 || prediction.x >= groundWidth / 2 - 0.5) {
              predictedVel.x *= -1;
            }
          }

          // добавляем разброс в предсказание (чем сложнее — тем меньше разброс)
          aiTargetX = prediction.x + (Math.random() - 0.5) * randomness;
        } else {
          aiTargetX = ai.position.x;
        }
      }

      function moveTowards(current, target, maxDelta) {
        const delta = target - current;
        if (Math.abs(delta) <= maxDelta) return target;
        return current + Math.sign(delta) * maxDelta;
      }

      scene.onBeforeRenderObservable.add(() => {
        const dt = engine.getDeltaTime() / 1000;

        const moveSpeed = baseMoveSpeed;
        const aiMoveSpeed = baseMoveSpeed; // всегда равна скорости игрока

        if (input.a && player.position.x > -groundWidth/2 + 1) player.position.x -= moveSpeed * dt;
        if (input.d && player.position.x < groundWidth/2 - 1) player.position.x += moveSpeed * dt;

        predictBallPosition();
        ai.position.x = moveTowards(ai.position.x, aiTargetX, aiMoveSpeed * dt);

        ball.position.addInPlace(ballVelocity);

        const leftLimit = -groundWidth/2 + 0.5;
        const rightLimit = groundWidth/2 - 0.5;
        if (ball.position.x <= leftLimit && ballVelocity.x < 0) {
          ballVelocity.x *= -1;
          ball.position.x = leftLimit;
        }
        if (ball.position.x >= rightLimit && ballVelocity.x > 0) {
          ballVelocity.x *= -1;
          ball.position.x = rightLimit;
        }

        if (paddleHit(player) && ballVelocity.z < 0) {
          reflectBall(player);
        }
        if (paddleHit(ai) && ballVelocity.z > 0) {
          reflectBall(ai);
        }

        if (ball.position.z < player.position.z - 3) {
          aiScore++;
          updateScore();
          resetBall();
        } else if (ball.position.z > ai.position.z + 3) {
          playerScore++;
          updateScore();
          resetBall();
        }
      });

      return scene;
    }



    document.getElementById("restartButton").addEventListener("click", () => {
  // Сброс счёта
  playerScore = 0;
  aiScore = 0;
  scoreboard.textContent = `Player: ${playerScore} | AI: ${aiScore}`;

  // Скрыть экран победителя
  document.getElementById("winnerScreen").style.display = "none";

  // Показать меню выбора сложности (если хочешь)
  difficultyMenu.style.display = "block";
  ScorCont.style.display = "block";

  // Перезапуск игры произойдёт после выбора сложности
});
  </script>
</body>
</html>
